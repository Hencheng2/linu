<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Linux Terminal Web Tool</title>
  <style>
    body {
      margin: 0;
      font-family: monospace, monospace;
      background-color: #111;
      color: #eee;
      display: flex;
      height: 100vh;
    }
    aside {
      width: 300px;
      background: #1a1a1a;
      border-right: 1px solid #333;
      padding: 10px;
      overflow-y: auto;
    }
    aside h2 { font-size: 16px; margin-top: 0; }
    aside input {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      background: #222;
      border: 1px solid #444;
      color: #eee;
    }
    aside .cmd {
      padding: 5px;
      background: #222;
      margin-bottom: 5px;
      border-radius: 4px;
      font-size: 12px;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 10px;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
    }
    #output {
      flex: 1;
      padding: 10px;
      background: #000;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    #prompt-line {
      display: flex;
      align-items: center;
      padding: 8px;
      background: #111;
    }
    #prompt {
      color: #0f0;
      margin-right: 5px;
    }
    #input {
      flex: 1;
      padding: 5px;
      background: #222;
      border: none;
      color: #fff;
      outline: none;
    }
    #editorModal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
    }
    #editorHeader {
      background: #222;
      padding: 5px;
      font-size: 14px;
      color: #0f0;
    }
    #editorArea {
      flex: 1;
      background: #000;
      color: #fff;
      padding: 10px;
      border: none;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      outline: none;
      line-height: 1.4em;
    }
    #editorFooter {
      background: #222;
      padding: 5px;
      font-size: 12px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <aside>
    <h2>Commands & Usage</h2>
    <input type="text" id="filter" placeholder="Filter commands...">
    <div id="commands-list"></div>
    <p style="font-size:10px; color:#888;">
      Runs in your browser only. Commands are simulated — no real shell access.
    </p>
  </aside>
  <main>
    <header>
      <strong>Linux Terminal Emulator</strong>
      <button id="clearBtn">Clear</button>
    </header>
    <div id="output"></div>
    <div id="prompt-line">
      <span id="prompt">user@web:~$</span>
      <input id="input" autofocus autocomplete="off" placeholder="Type a command...">
    </div>
  </main>

  <!-- Nano-like Editor -->
  <div id="editorModal">
    <div id="editorHeader">Nano Editor — Press Ctrl+S to Save, Ctrl+X to Exit</div>
    <textarea id="editorArea"></textarea>
    <div id="editorFooter">^S Save   ^X Exit</div>
  </div>

  <script>
    const outputEl = document.getElementById("output");
    const inputEl = document.getElementById("input");
    const promptEl = document.getElementById("prompt");
    const clearBtn = document.getElementById("clearBtn");
    const filterEl = document.getElementById("filter");
    const commandsListEl = document.getElementById("commands-list");

    const commandsMeta = {
      ls: "List directory contents",
      pwd: "Print working directory",
      cd: "Change directory",
      cat: "Print file contents",
      echo: "Display text (supports > and >> redirection)",
      touch: "Create empty file",
      mkdir: "Create directory",
      rm: "Remove file or dir",
      nano: "Open file in editor",
      tree: "Display directory tree",
      date: "Show date",
      uname: "System info",
      whoami: "Current user",
      clear: "Clear the terminal",
      help: "List available commands",
      history: "Show command history",
      man: "Manual page (simulated)",
      grep: "Search text in input",
      wc: "Count lines/words/chars"
    };

    function refreshCommandsList(filter="") {
      commandsListEl.innerHTML = "";
      Object.entries(commandsMeta)
        .filter(([k]) => k.includes(filter))
        .forEach(([cmd, desc]) => {
          const div = document.createElement("div");
          div.className = "cmd";
          div.textContent = `${cmd} — ${desc}`;
          commandsListEl.appendChild(div);
        });
    }
    refreshCommandsList();
    filterEl.addEventListener("input", () => {
      refreshCommandsList(filterEl.value);
    });

    // Simulated filesystem
    let fs = {
      type: "dir",
      name: "/",
      children: {
        home: {
          type: "dir",
          name: "home",
          children: {
            user: {
              type: "dir",
              name: "user",
              children: {}
            }
          }
        }
      }
    };
    let cwdPath = ["/","home","user"];

    function getNode(pathArr) {
      let node = fs;
      for (let i=1;i<pathArr.length;i++) {
        node = node.children[pathArr[i]];
        if (!node) return null;
      }
      return node;
    }

    function resolvePath(path) {
      let parts = path.startsWith("/") ? ["/"] : [...cwdPath];
      for (let p of path.split("/")) {
        if (!p || p === ".") continue;
        if (p === "..") {
          if (parts.length > 1) parts.pop();
        } else {
          parts.push(p);
        }
      }
      return parts;
    }

    function pathString(parts) {
      return parts.length === 1 ? "/" : parts.join("/").replace("//","/");
    }

    let history = [];
    let histIndex = null;

    function print(text, type="out") {
      const div = document.createElement("div");
      div.textContent = text;
      div.style.color = type === "cmd" ? "#6cf" : "#ccc";
      outputEl.appendChild(div);
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    // Nano Editor
    const editorModal = document.getElementById("editorModal");
    const editorArea = document.getElementById("editorArea");
    let editingFile = null;

    function openEditor(fileNode, path) {
      editorModal.style.display = "flex";
      editorArea.value = fileNode.content || "";
      editingFile = { node: fileNode, path };
      editorArea.focus();
    }

    document.addEventListener("keydown", (e) => {
      if (editorModal.style.display === "flex") {
        if (e.ctrlKey && e.key.toLowerCase() === "s") {
          e.preventDefault();
          editingFile.node.content = editorArea.value;
          alert("File saved: " + pathString(editingFile.path));
        }
        if (e.ctrlKey && e.key.toLowerCase() === "x") {
          e.preventDefault();
          editorModal.style.display = "none";
          editingFile = null;
          inputEl.focus();
        }
      }
    });

    function drawTree(node, prefix="") {
      let res = node.name + (node.type==="dir" ? "/" : "");
      if (node.type==="dir") {
        const keys = Object.keys(node.children);
        keys.forEach((k, idx) => {
          const child = node.children[k];
          const isLast = idx === keys.length - 1;
          const connector = isLast ? "└── " : "├── ";
          const subprefix = prefix + (isLast ? "    " : "│   ");
          res += "\n" + prefix + connector + drawTree(child, subprefix);
        });
      }
      return res;
    }

    function runSingleCommand(cmd, inputText="") {
      const [command, ...args] = cmd.trim().split(/\s+/);
      let res = "";

      switch(command) {
        case "pwd": return pathString(cwdPath);
        case "ls": {
          const targetPath = resolvePath(args[0] || ".");
          const node = getNode(targetPath);
          return (!node || node.type !== "dir") ? "No such directory" : Object.keys(node.children).join("  ");
        }
        case "cd": {
          const targetPath = resolvePath(args[0] || "/home/user");
          const node = getNode(targetPath);
          if (node && node.type === "dir") cwdPath = targetPath;
          else return "No such directory";
          return "";
        }
        case "mkdir": {
          if (!args[0]) return "Missing operand";
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.type==="dir") {
            parent.children[targetPath.at(-1)] = {type:"dir",name:targetPath.at(-1),children:{}};
          } else return "Cannot create directory";
          return "";
        }
        case "touch": {
          if (!args[0]) return "Missing operand";
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.type==="dir") {
            parent.children[targetPath.at(-1)] = {type:"file",name:targetPath.at(-1),content:""};
          } else return "Cannot create file";
          return "";
        }
        case "cat": {
          if (!args[0]) return "Missing operand";
          const node = getNode(resolvePath(args[0]));
          return (node && node.type==="file") ? node.content||"" : "No such file";
        }
        case "rm": {
          if (!args[0]) return "Missing operand";
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.children[targetPath.at(-1)]) {
            delete parent.children[targetPath.at(-1)];
          } else return "No such file or directory";
          return "";
        }
        case "nano": {
          if (!args[0]) return "Missing operand";
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (!parent || parent.type!=="dir") return "Cannot open file";
          if (!parent.children[targetPath.at(-1)]) {
            parent.children[targetPath.at(-1)] = {type:"file",name:targetPath.at(-1),content:""};
          }
          openEditor(parent.children[targetPath.at(-1)], targetPath);
          return "";
        }
        case "tree": {
          const targetPath = resolvePath(args[0] || ".");
          const node = getNode(targetPath);
          return node ? drawTree(node) : "No such directory";
        }
        case "date": return new Date().toString();
        case "uname": return "Linux simulated 5.15.0 x86_64";
        case "whoami": return "user";
        case "help": return Object.keys(commandsMeta).join("  ");
        case "history": return history.join("\n");
        case "clear": outputEl.innerHTML = ""; return "";
        case "man": return args[0] && commandsMeta[args[0]]
            ? `${args[0]} — ${commandsMeta[args[0]]}\n(Simulated man page)`
            : "No manual entry";
        case "echo": return args.join(" ");
        case "grep": {
          if (!inputText) return "No input";
          if (!args[0]) return "Missing pattern";
          return inputText.split("\n").filter(line => line.includes(args[0])).join("\n");
        }
        case "wc": {
          const text = inputText || "";
          const lines = text.split("\n").length;
          const words = text.trim().split(/\s+/).filter(Boolean).length;
          const chars = text.length;
          return `${lines} ${words} ${chars}`;
        }
        default:
          return `${command}: command not found`;
      }
    }

    function runCommand(line) {
      if (!line.trim()) return;
      history.push(line);
      histIndex = null;
      print(promptEl.textContent + " " + line, "cmd");

      // Handle pipes
      let parts = line.split("|").map(s => s.trim());
      let input = "";
      let output = "";
      for (let i=0;i<parts.length;i++) {
        let segment = parts[i];

        // Handle redirection > and >>
        let redirectFile = null;
        let append = false;
        if (segment.includes(">>")) {
          [segment, redirectFile] = segment.split(">>").map(s => s.trim());
          append = true;
        } else if (segment.includes(">")) {
          [segment, redirectFile] = segment.split(">").map(s => s.trim());
        }

        output = runSingleCommand(segment, input);

        // Handle redirection
        if (redirectFile) {
          const targetPath = resolvePath(redirectFile);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.type==="dir") {
            if (!parent.children[targetPath.at(-1)]) {
              parent.children[targetPath.at(-1)] = {type:"file",name:targetPath.at(-1),content:""};
            }
            if (append) parent.children[targetPath.at(-1)].content += output + "\n";
            else parent.children[targetPath.at(-1)].content = output + "\n";
          } else {
            print("Redirection failed: cannot write to file");
          }
          output = ""; // do not show on screen
        }

        input = output;
      }

      if (output) print(output);
      promptEl.textContent = `user@web:${pathString(cwdPath)}$`;
    }

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        runCommand(inputEl.value);
        inputEl.value = "";
      } else if (e.key === "ArrowUp") {
        if (history.length > 0) {
          histIndex = histIndex === null ? history.length - 1 : Math.max(0, histIndex - 1);
          inputEl.value = history[histIndex];
        }
      } else if (e.key === "ArrowDown") {
        if (histIndex !== null) {
          histIndex = Math.min(history.length - 1, histIndex + 1);
          inputEl.value = history[histIndex] || "";
        }
      } else if (e.key === "Tab") {
        e.preventDefault();
        // simple autocomplete for commands
        let val = inputEl.value;
        let parts = val.split(/\s+/);
        if (parts.length === 1) {
          let matches = Object.keys(commandsMeta).filter(c => c.startsWith(parts[0]));
          if (matches.length === 1) inputEl.value = matches[0] + " ";
          else if (matches.length > 1) print(matches.join("  "));
        }
      }
    });

    clearBtn.addEventListener("click", () => {
      outputEl.innerHTML = "";
    });
  </script>
</body>
</html>
