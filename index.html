<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Linux Terminal Web Tool</title>
  <style>
    body {
      margin: 0;
      font-family: monospace, monospace;
      background-color: #111;
      color: #eee;
      display: flex;
      height: 100vh;
    }
    aside {
      width: 300px;
      background: #1a1a1a;
      border-right: 1px solid #333;
      padding: 10px;
      overflow-y: auto;
    }
    aside h2 { font-size: 16px; margin-top: 0; }
    aside input {
      width: 100%;
      padding: 5px;
      margin-bottom: 10px;
      background: #222;
      border: 1px solid #444;
      color: #eee;
    }
    aside .cmd {
      padding: 5px;
      background: #222;
      margin-bottom: 5px;
      border-radius: 4px;
      font-size: 12px;
    }
    main {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 10px;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
      display: flex;
      justify-content: space-between;
    }
    #output {
      flex: 1;
      padding: 10px;
      background: #000;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    #prompt-line {
      display: flex;
      align-items: center;
      padding: 8px;
      background: #111;
    }
    #prompt {
      color: #0f0;
      margin-right: 5px;
    }
    #input {
      flex: 1;
      padding: 5px;
      background: #222;
      border: none;
      color: #fff;
      outline: none;
    }
    #editorModal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
    }
    #editorHeader {
      background: #222;
      padding: 5px;
      font-size: 14px;
      color: #0f0;
    }
    #editorArea {
      flex: 1;
      background: #000;
      color: #fff;
      padding: 10px;
      border: none;
      resize: none;
      font-family: monospace;
      font-size: 14px;
      outline: none;
      line-height: 1.4em;
    }
    #editorFooter {
      background: #222;
      padding: 5px;
      font-size: 12px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <aside>
    <h2>Commands & Usage</h2>
    <input type="text" id="filter" placeholder="Filter commands...">
    <div id="commands-list"></div>
    <p style="font-size:10px; color:#888;">
      Runs in your browser only. Commands are simulated — no real shell access.
    </p>
  </aside>
  <main>
    <header>
      <strong>Linux Terminal Emulator</strong>
      <button id="clearBtn">Clear</button>
    </header>
    <div id="output"></div>
    <div id="prompt-line">
      <span id="prompt">user@web:~$</span>
      <input id="input" autofocus autocomplete="off" placeholder="Type a command...">
    </div>
  </main>

  <!-- Nano-like Editor -->
  <div id="editorModal">
    <div id="editorHeader">Nano Editor — Press Ctrl+S to Save, Ctrl+X to Exit</div>
    <textarea id="editorArea"></textarea>
    <div id="editorFooter">^S Save   ^X Exit</div>
  </div>

  <script>
    const outputEl = document.getElementById("output");
    const inputEl = document.getElementById("input");
    const promptEl = document.getElementById("prompt");
    const clearBtn = document.getElementById("clearBtn");
    const filterEl = document.getElementById("filter");
    const commandsListEl = document.getElementById("commands-list");

    const commandsMeta = {
      ls: "List directory contents",
      pwd: "Print working directory",
      cd: "Change directory",
      cat: "Print file contents",
      echo: "Display text (supports > and >> redirection)",
      touch: "Create empty file",
      mkdir: "Create directory",
      rm: "Remove file or dir",
      nano: "Open file in editor",
      tree: "Display directory tree",
      date: "Show date",
      uname: "System info",
      whoami: "Current user",
      clear: "Clear the terminal",
      help: "List available commands",
      history: "Show command history",
      man: "Manual page (simulated)"
    };

    function refreshCommandsList(filter="") {
      commandsListEl.innerHTML = "";
      Object.entries(commandsMeta)
        .filter(([k]) => k.includes(filter))
        .forEach(([cmd, desc]) => {
          const div = document.createElement("div");
          div.className = "cmd";
          div.textContent = `${cmd} — ${desc}`;
          commandsListEl.appendChild(div);
        });
    }
    refreshCommandsList();
    filterEl.addEventListener("input", () => {
      refreshCommandsList(filterEl.value);
    });

    // Simulated filesystem
    let fs = {
      type: "dir",
      name: "/",
      children: {
        home: {
          type: "dir",
          name: "home",
          children: {
            user: {
              type: "dir",
              name: "user",
              children: {}
            }
          }
        }
      }
    };
    let cwdPath = ["/","home","user"];

    function getNode(pathArr) {
      let node = fs;
      for (let i=1;i<pathArr.length;i++) {
        node = node.children[pathArr[i]];
        if (!node) return null;
      }
      return node;
    }

    function resolvePath(path) {
      let parts = path.startsWith("/") ? ["/"] : [...cwdPath];
      for (let p of path.split("/")) {
        if (!p || p === ".") continue;
        if (p === "..") {
          if (parts.length > 1) parts.pop();
        } else {
          parts.push(p);
        }
      }
      return parts;
    }

    function pathString(parts) {
      return parts.length === 1 ? "/" : parts.join("/").replace("//","/");
    }

    let history = [];
    let histIndex = null;

    function print(text, type="out") {
      const div = document.createElement("div");
      div.textContent = text;
      div.style.color = type === "cmd" ? "#6cf" : "#ccc";
      outputEl.appendChild(div);
      outputEl.scrollTop = outputEl.scrollHeight;
    }

    // Nano Editor
    const editorModal = document.getElementById("editorModal");
    const editorArea = document.getElementById("editorArea");
    let editingFile = null;

    function openEditor(fileNode, path) {
      editorModal.style.display = "flex";
      editorArea.value = fileNode.content || "";
      editingFile = { node: fileNode, path };
      editorArea.focus();
    }

    document.addEventListener("keydown", (e) => {
      if (editorModal.style.display === "flex") {
        if (e.ctrlKey && e.key.toLowerCase() === "s") {
          e.preventDefault();
          editingFile.node.content = editorArea.value;
          alert("File saved: " + pathString(editingFile.path));
        }
        if (e.ctrlKey && e.key.toLowerCase() === "x") {
          e.preventDefault();
          editorModal.style.display = "none";
          editingFile = null;
          inputEl.focus();
        }
      }
    });

    function drawTree(node, prefix="") {
      let res = node.name + (node.type==="dir" ? "/" : "");
      if (node.type==="dir") {
        const keys = Object.keys(node.children);
        keys.forEach((k, idx) => {
          const child = node.children[k];
          const isLast = idx === keys.length - 1;
          const connector = isLast ? "└── " : "├── ";
          const subprefix = prefix + (isLast ? "    " : "│   ");
          res += "\n" + prefix + connector + drawTree(child, subprefix);
        });
      }
      return res;
    }

    function runCommand(line) {
      if (!line.trim()) return;
      history.push(line);
      histIndex = null;
      print(promptEl.textContent + " " + line, "cmd");

      const [cmd, ...args] = line.split(/\s+/);
      let res = "";

      switch(cmd) {
        case "pwd": res = pathString(cwdPath); break;
        case "ls": {
          const targetPath = resolvePath(args[0] || ".");
          const node = getNode(targetPath);
          res = (!node || node.type !== "dir") ? "No such directory" : Object.keys(node.children).join("  ");
          break;
        }
        case "cd": {
          const targetPath = resolvePath(args[0] || "/home/user");
          const node = getNode(targetPath);
          if (node && node.type === "dir") cwdPath = targetPath;
          else res = "No such directory";
          break;
        }
        case "mkdir": {
          if (!args[0]) {res="Missing operand"; break;}
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.type==="dir") {
            parent.children[targetPath.at(-1)] = {type:"dir",name:targetPath.at(-1),children:{}};
          } else res="Cannot create directory";
          break;
        }
        case "touch": {
          if (!args[0]) {res="Missing operand"; break;}
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.type==="dir") {
            parent.children[targetPath.at(-1)] = {type:"file",name:targetPath.at(-1),content:""};
          } else res="Cannot create file";
          break;
        }
        case "cat": {
          if (!args[0]) {res="Missing operand"; break;}
          const node = getNode(resolvePath(args[0]));
          res = (node && node.type==="file") ? node.content||"" : "No such file";
          break;
        }
        case "rm": {
          if (!args[0]) {res="Missing operand"; break;}
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (parent && parent.children[targetPath.at(-1)]) {
            delete parent.children[targetPath.at(-1)];
          } else res="No such file or directory";
          break;
        }
        case "nano": {
          if (!args[0]) {res="Missing operand"; break;}
          const targetPath = resolvePath(args[0]);
          const parent = getNode(targetPath.slice(0,-1));
          if (!parent || parent.type!=="dir") {res="Cannot open file"; break;}
          if (!parent.children[targetPath.at(-1)]) {
            parent.children[targetPath.at(-1)] = {type:"file",name:targetPath.at(-1),content:""};
          }
          const file = parent.children[targetPath.at(-1)];
          openEditor(file, targetPath);
          return;
        }
        case "tree": {
          const targetPath = resolvePath(args[0] || ".");
          const node = getNode(targetPath);
          res = node ? drawTree(node) : "No such directory";
          break;
        }
        case "date": res = new Date().toString(); break;
        case "uname": res = "Linux simulated 5.15.0 x86_64"; break;
        case "whoami": res = "user"; break;
        case "help": res = Object.keys(commandsMeta).join("  "); break;
        case "history": res = history.join("\n"); break;
        case "clear": outputEl.innerHTML = ""; return;
        case "man":
          res = args[0] && commandsMeta[args[0]]
            ? `${args[0]} — ${commandsMeta[args[0]]}\n(Simulated man page)`
            : "No manual entry";
          break;
        default:
          res = `${cmd}: command not found`;
      }

      if (res) print(res);
      promptEl.textContent = `user@web:${pathString(cwdPath)}$`;
    }

    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        runCommand(inputEl.value);
        inputEl.value = "";
      } else if (e.key === "ArrowUp") {
        if (history.length > 0) {
          histIndex = histIndex === null ? history.length - 1 : Math.max(0, histIndex - 1);
          inputEl.value = history[histIndex];
        }
      } else if (e.key === "ArrowDown") {
        if (histIndex !== null) {
          histIndex = Math.min(history.length - 1, histIndex + 1);
          inputEl.value = history[histIndex] || "";
        }
      }
    });

    clearBtn.addEventListener("click", () => {
      outputEl.innerHTML = "";
    });
  </script>
</body>
</html>
